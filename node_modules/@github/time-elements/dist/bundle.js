var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// dist/duration-format.js
var unitNames = ["second", "minute", "hour", "day", "month", "year"];
function timeAgo(date) {
  const ms = new Date().getTime() - date.getTime();
  const sec = Math.round(ms / 1e3);
  const min = Math.round(sec / 60);
  const hr = Math.round(min / 60);
  const day = Math.round(hr / 24);
  const month = Math.round(day / 30);
  const year = Math.round(month / 12);
  if (ms < 0) {
    return [0, "second"];
  } else if (sec < 10) {
    return [0, "second"];
  } else if (sec < 45) {
    return [-sec, "second"];
  } else if (sec < 90) {
    return [-min, "minute"];
  } else if (min < 45) {
    return [-min, "minute"];
  } else if (min < 90) {
    return [-hr, "hour"];
  } else if (hr < 24) {
    return [-hr, "hour"];
  } else if (hr < 36) {
    return [-day, "day"];
  } else if (day < 30) {
    return [-day, "day"];
  } else if (month < 18) {
    return [-month, "month"];
  } else {
    return [-year, "year"];
  }
}
__name(timeAgo, "timeAgo");
function microTimeAgo(date) {
  const ms = new Date().getTime() - date.getTime();
  const sec = Math.round(ms / 1e3);
  const min = Math.round(sec / 60);
  const hr = Math.round(min / 60);
  const day = Math.round(hr / 24);
  const month = Math.round(day / 30);
  const year = Math.round(month / 12);
  if (min < 1) {
    return [1, "minute"];
  } else if (min < 60) {
    return [min, "minute"];
  } else if (hr < 24) {
    return [hr, "hour"];
  } else if (day < 365) {
    return [day, "day"];
  } else {
    return [year, "year"];
  }
}
__name(microTimeAgo, "microTimeAgo");
function timeUntil(date) {
  const ms = date.getTime() - new Date().getTime();
  const sec = Math.round(ms / 1e3);
  const min = Math.round(sec / 60);
  const hr = Math.round(min / 60);
  const day = Math.round(hr / 24);
  const month = Math.round(day / 30);
  const year = Math.round(month / 12);
  if (month >= 18) {
    return [year, "year"];
  } else if (month >= 12) {
    return [year, "year"];
  } else if (day >= 45) {
    return [month, "month"];
  } else if (day >= 30) {
    return [month, "month"];
  } else if (hr >= 36) {
    return [day, "day"];
  } else if (hr >= 24) {
    return [day, "day"];
  } else if (min >= 90) {
    return [hr, "hour"];
  } else if (min >= 45) {
    return [hr, "hour"];
  } else if (sec >= 90) {
    return [min, "minute"];
  } else if (sec >= 45) {
    return [min, "minute"];
  } else if (sec >= 10) {
    return [sec, "second"];
  } else {
    return [0, "second"];
  }
}
__name(timeUntil, "timeUntil");
function microTimeUntil(date) {
  const ms = date.getTime() - new Date().getTime();
  const sec = Math.round(ms / 1e3);
  const min = Math.round(sec / 60);
  const hr = Math.round(min / 60);
  const day = Math.round(hr / 24);
  const month = Math.round(day / 30);
  const year = Math.round(month / 12);
  if (day >= 365) {
    return [year, "year"];
  } else if (hr >= 24) {
    return [day, "day"];
  } else if (min >= 60) {
    return [hr, "hour"];
  } else if (min > 1) {
    return [min, "minute"];
  } else {
    return [1, "minute"];
  }
}
__name(microTimeUntil, "microTimeUntil");
function elapsedTime(date) {
  const ms = Math.abs(date.getTime() - new Date().getTime());
  const sec = Math.floor(ms / 1e3);
  const min = Math.floor(sec / 60);
  const hr = Math.floor(min / 60);
  const day = Math.floor(hr / 24);
  const month = Math.floor(day / 30);
  const year = Math.floor(month / 12);
  const units = [];
  if (year)
    units.push([year, "year"]);
  if (month - year * 12)
    units.push([month - year * 12, "month"]);
  if (day - month * 30)
    units.push([day - month * 30, "day"]);
  if (hr - day * 24)
    units.push([hr - day * 24, "hour"]);
  if (min - hr * 60)
    units.push([min - hr * 60, "minute"]);
  if (sec - min * 60)
    units.push([sec - min * 60, "second"]);
  return units;
}
__name(elapsedTime, "elapsedTime");

// dist/strftime.js
var supportsIntlDatetime = typeof Intl !== "undefined" && "DateTimeFormat" in Intl;
var weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var months = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
function strftime(time, formatString, lang) {
  const day = time.getDay();
  const date = time.getDate();
  const month = time.getMonth();
  const year = time.getFullYear();
  const hour = time.getHours();
  const minute = time.getMinutes();
  const second = time.getSeconds();
  const useIntl = lang && supportsIntlDatetime;
  const shortParts = useIntl && new Intl.DateTimeFormat(lang, { weekday: "short", month: "short" }).formatToParts(time);
  const longParts = useIntl && new Intl.DateTimeFormat(lang, { weekday: "long", month: "long" }).formatToParts(time);
  return formatString.replace(/%([%aAbBcdeHIlmMpPSwyYZz])/g, function(_arg) {
    let match;
    const modifier = _arg[1];
    switch (modifier) {
      case "%":
        return "%";
      case "a":
        if (shortParts) {
          const weekdayPart = shortParts.find((part) => part.type === "weekday");
          if (weekdayPart)
            return weekdayPart.value;
        }
        return weekdays[day].slice(0, 3);
      case "A":
        if (longParts) {
          const weekdayPart = longParts.find((part) => part.type === "weekday");
          if (weekdayPart)
            return weekdayPart.value;
        }
        return weekdays[day];
      case "b":
        if (shortParts) {
          const monthPart = shortParts.find((part) => part.type === "month");
          if (monthPart)
            return monthPart.value;
        }
        return months[month].slice(0, 3);
      case "B":
        if (longParts) {
          const monthPart = longParts.find((part) => part.type === "month");
          if (monthPart)
            return monthPart.value;
        }
        return months[month];
      case "c":
        return time.toString();
      case "d":
        return String(date).padStart(2, "0");
      case "e":
        return String(date);
      case "H":
        return String(hour).padStart(2, "0");
      case "I":
        if (hour === 0 || hour === 12) {
          return String(12);
        } else {
          return String((hour + 12) % 12).padStart(2, "0");
        }
      case "l":
        if (hour === 0 || hour === 12) {
          return String(12);
        } else {
          return String((hour + 12) % 12).padStart(2, " ");
        }
      case "m":
        return String(month + 1).padStart(2, "0");
      case "M":
        return String(minute).padStart(2, "0");
      case "p":
        if (hour > 11) {
          return "PM";
        } else {
          return "AM";
        }
      case "P":
        if (hour > 11) {
          return "pm";
        } else {
          return "am";
        }
      case "S":
        return String(second).padStart(2, "0");
      case "w":
        return String(day);
      case "y":
        return String(year % 100).padStart(2, "0");
      case "Y":
        return String(year);
      case "Z":
        match = time.toString().match(/\((\w+)\)$/);
        return match ? match[1] : "";
      case "z":
        match = time.toString().match(/\w([+-]\d\d\d\d) /);
        return match ? match[1] : "";
    }
    return "";
  });
}
__name(strftime, "strftime");

// dist/datetimeformat-ponyfill.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DateTimeFormat_options;
var DateTimeFormat = class {
  constructor(locale, options) {
    var _a;
    _DateTimeFormat_options.set(this, void 0);
    __classPrivateFieldSet(this, _DateTimeFormat_options, {
      locale: "en",
      calendar: "gregory",
      numberingSystem: "latn",
      weekday: options.weekday,
      minute: options.minute,
      hour: options.hour,
      day: options.day,
      month: options.month,
      year: options.year,
      timeZone: (_a = options.timeZone) !== null && _a !== void 0 ? _a : ""
    }, "f");
    if (!Object.keys(options).length) {
      __classPrivateFieldGet(this, _DateTimeFormat_options, "f").day = "2-digit";
      __classPrivateFieldGet(this, _DateTimeFormat_options, "f").month = "2-digit";
      __classPrivateFieldGet(this, _DateTimeFormat_options, "f").year = "numeric";
    }
  }
  formatToParts() {
    return [];
  }
  resolvedOptions() {
    return __classPrivateFieldGet(this, _DateTimeFormat_options, "f");
  }
  format(value) {
    let str = "";
    const { weekday, month, day, year, hour, minute, second } = this.resolvedOptions();
    if (weekday === "long")
      str += "%A";
    if (weekday === "short")
      str += "%a";
    if (weekday === "narrow")
      str += "%a";
    if ((month === "numeric" || month === "2-digit") && day && year) {
      str += `${weekday ? ", " : ""}%m/%d/%${year === "2-digit" ? "y" : "Y"}`;
    } else {
      if (month === "numeric")
        str += `${weekday ? ", " : ""}%m`;
      if (month === "2-digit")
        str += `${weekday ? ", " : ""}%m`;
      if (month === "long")
        str += `${weekday ? ", " : ""}%B`;
      if (month === "short")
        str += `${weekday ? ", " : ""}%b`;
      if (month === "narrow")
        str += `${weekday ? ", " : ""}%b`;
      if (day === "numeric")
        str += " %e";
      if (day === "2-digit")
        str += " %d";
      if (year === "numeric")
        str += ", %Y";
      if (year === "2-digit")
        str += ", %y";
    }
    if (hour === "numeric")
      str += `${str ? "," : ""}%l`;
    if (hour === "2-digit")
      str += `${str ? ", " : ""}%H`;
    if (minute === "numeric")
      str += `${hour ? ":" : ""}%M`;
    if (minute === "2-digit")
      str += `${hour ? ":" : ""}%M`;
    if (second === "numeric")
      str += `${hour ? ":" : ""}%S`;
    if (second === "2-digit")
      str += `${hour || minute ? ":" : ""}%S`;
    if (hour)
      str += " %p";
    return strftime(new Date(value), str.trim());
  }
};
__name(DateTimeFormat, "DateTimeFormat");
_DateTimeFormat_options = /* @__PURE__ */ new WeakMap();

// dist/relative-time-ponyfill.js
var RelativeTimeFormat = class {
  formatToParts() {
    return [];
  }
  resolvedOptions() {
    return { locale: "en", style: "long", numeric: "auto", numberingSystem: "nu" };
  }
  format(value, unit) {
    if (value === 0) {
      switch (unit) {
        case "year":
        case "quarter":
        case "month":
        case "week":
          return `this ${unit}`;
        case "day":
          return "today";
        case "hour":
        case "minute":
          return `in 0 ${unit}s`;
        case "second":
          return "now";
      }
    } else if (value === 1) {
      switch (unit) {
        case "year":
        case "quarter":
        case "month":
        case "week":
          return `next ${unit}`;
        case "day":
          return "tomorrow";
        case "hour":
        case "minute":
        case "second":
          return `in 1 ${unit}`;
      }
    } else if (value === -1) {
      switch (unit) {
        case "year":
        case "quarter":
        case "month":
        case "week":
          return `last ${unit}`;
        case "day":
          return "yesterday";
        case "hour":
        case "minute":
        case "second":
          return `1 ${unit} ago`;
      }
    } else if (value > 1) {
      switch (unit) {
        case "year":
        case "quarter":
        case "month":
        case "week":
        case "day":
        case "hour":
        case "minute":
        case "second":
          return `in ${value} ${unit}s`;
      }
    } else if (value < -1) {
      switch (unit) {
        case "year":
        case "quarter":
        case "month":
        case "week":
        case "day":
        case "hour":
        case "minute":
        case "second":
          return `${-value} ${unit}s ago`;
      }
    }
    throw new RangeError(`Invalid unit argument for format() '${unit}'`);
  }
};
__name(RelativeTimeFormat, "RelativeTimeFormat");

// dist/duration.js
var durationRe = /^[-+]?P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?$/;
var isDuration = /* @__PURE__ */ __name((str) => durationRe.test(str), "isDuration");
var Duration = class {
  constructor(years = 0, months2 = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0) {
    this.years = years;
    this.months = months2;
    this.weeks = weeks;
    this.days = days;
    this.hours = hours;
    this.minutes = minutes;
    this.seconds = seconds;
  }
  abs() {
    return new Duration(Math.abs(this.years), Math.abs(this.months), Math.abs(this.weeks), Math.abs(this.days), Math.abs(this.hours), Math.abs(this.minutes), Math.abs(this.seconds));
  }
  static from(durationLike) {
    var _a;
    if (typeof durationLike === "string") {
      const str = String(durationLike).trim();
      const factor = str.startsWith("-") ? -1 : 1;
      const parsed = (_a = str.match(durationRe)) === null || _a === void 0 ? void 0 : _a.slice(1).map((x) => (Number(x) || 0) * factor);
      if (!parsed)
        return new Duration();
      return new Duration(...parsed);
    } else if (typeof durationLike === "object") {
      const { years, months: months2, weeks, days, hours, minutes, seconds } = durationLike;
      return new Duration(years, months2, weeks, days, hours, minutes, seconds);
    }
    throw new RangeError("invalid duration");
  }
};
__name(Duration, "Duration");
function applyDuration(date, duration) {
  const r = new Date(date);
  r.setFullYear(r.getFullYear() + duration.years);
  r.setMonth(r.getMonth() + duration.months);
  r.setDate(r.getDate() + duration.weeks * 7 + duration.days);
  r.setHours(r.getHours() + duration.hours);
  r.setMinutes(r.getMinutes() + duration.minutes);
  r.setSeconds(r.getSeconds() + duration.seconds);
  return r;
}
__name(applyDuration, "applyDuration");
function withinDuration(a, b, str) {
  const duration = Duration.from(str).abs();
  const threshold = applyDuration(a, duration);
  if (!threshold)
    return true;
  return Math.abs(Number(threshold) - Number(a)) > Math.abs(Number(a) - Number(b));
}
__name(withinDuration, "withinDuration");

// dist/relative-time-element.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _RelativeTimeElement_instances;
var _RelativeTimeElement_customTitle;
var _RelativeTimeElement_updating;
var _RelativeTimeElement_lang_get;
var _RelativeTimeElement_renderRoot;
var root = typeof globalThis !== "undefined" ? globalThis : window;
var HTMLElement = root.HTMLElement || null;
var supportsIntlDatetime2 = typeof Intl !== "undefined" && "DateTimeFormat" in Intl;
var DateTimeFormat2 = supportsIntlDatetime2 ? Intl.DateTimeFormat : DateTimeFormat;
var supportsIntlRelativeTime = typeof Intl !== "undefined" && "RelativeTimeFormat" in Intl;
var RelativeTimeFormat2 = supportsIntlRelativeTime ? Intl.RelativeTimeFormat : RelativeTimeFormat;
var RelativeTimeUpdatedEvent = class extends Event {
  constructor(oldText, newText, oldTitle, newTitle) {
    super("relative-time-updated", { bubbles: true, composed: true });
    this.oldText = oldText;
    this.newText = newText;
    this.oldTitle = oldTitle;
    this.newTitle = newTitle;
  }
};
__name(RelativeTimeUpdatedEvent, "RelativeTimeUpdatedEvent");
function getUnitFactor(el) {
  if (!el.date)
    return Infinity;
  if (el.format === "elapsed") {
    const precision = el.precision;
    if (precision === "second") {
      return 1e3;
    } else if (precision === "minute") {
      return 60 * 1e3;
    }
  }
  const ms = Math.abs(Date.now() - el.date.getTime());
  if (ms < 60 * 1e3)
    return 1e3;
  if (ms < 60 * 60 * 1e3)
    return 60 * 1e3;
  return 60 * 60 * 1e3;
}
__name(getUnitFactor, "getUnitFactor");
var dateObserver = new class {
  constructor() {
    this.elements = /* @__PURE__ */ new Set();
    this.time = Infinity;
    this.timer = -1;
  }
  observe(element) {
    if (this.elements.has(element))
      return;
    this.elements.add(element);
    const date = element.date;
    if (date && date.getTime()) {
      const ms = getUnitFactor(element);
      const time = Date.now() + ms;
      if (time < this.time) {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => this.update(), ms);
        this.time = time;
      }
    }
  }
  unobserve(element) {
    if (!this.elements.has(element))
      return;
    this.elements.delete(element);
  }
  update() {
    clearTimeout(this.timer);
    if (!this.elements.size)
      return;
    let nearestDistance = Infinity;
    for (const timeEl of this.elements) {
      nearestDistance = Math.min(nearestDistance, getUnitFactor(timeEl));
      timeEl.update();
    }
    this.time = Math.min(60 * 60 * 1e3, nearestDistance);
    this.timer = setTimeout(() => this.update(), this.time);
    this.time += Date.now();
  }
}();
var RelativeTimeElement = class extends HTMLElement {
  constructor() {
    super(...arguments);
    _RelativeTimeElement_instances.add(this);
    _RelativeTimeElement_customTitle.set(this, false);
    _RelativeTimeElement_updating.set(this, false);
    _RelativeTimeElement_renderRoot.set(this, this.shadowRoot ? this.shadowRoot : this.attachShadow ? this.attachShadow({ mode: "open" }) : this);
  }
  static get observedAttributes() {
    return [
      "second",
      "minute",
      "hour",
      "weekday",
      "day",
      "month",
      "year",
      "time-zone-name",
      "prefix",
      "threshold",
      "tense",
      "precision",
      "format",
      "datetime",
      "lang",
      "title"
    ];
  }
  getFormattedTitle() {
    const date = this.date;
    if (!date)
      return;
    return new DateTimeFormat2(__classPrivateFieldGet2(this, _RelativeTimeElement_instances, "a", _RelativeTimeElement_lang_get), {
      day: "numeric",
      month: "short",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
      timeZoneName: "short"
    }).format(date);
  }
  getFormattedDate(now = new Date()) {
    const date = this.date;
    if (!date)
      return;
    const format = this.format;
    if (format !== "auto" && format !== "micro" && format !== "elapsed") {
      return strftime(date, format, __classPrivateFieldGet2(this, _RelativeTimeElement_instances, "a", _RelativeTimeElement_lang_get));
    } else if (format === "elapsed") {
      const precisionIndex = unitNames.indexOf(this.precision) || 0;
      const units = elapsedTime(date).filter((unit) => unitNames.indexOf(unit[1]) >= precisionIndex);
      return units.map(([int, unit]) => `${int}${unit[0]}`).join(" ") || `0${this.precision[0]}`;
    }
    const tense = this.tense;
    const micro = format === "micro";
    const inFuture = now.getTime() < date.getTime();
    const within = withinDuration(now, date, this.threshold);
    const locale = __classPrivateFieldGet2(this, _RelativeTimeElement_instances, "a", _RelativeTimeElement_lang_get);
    const relativeFormat = new RelativeTimeFormat2(locale, { numeric: "auto" });
    if (tense === "past" || tense === "auto" && !inFuture && within) {
      const [int, unit] = micro ? microTimeAgo(date) : timeAgo(date);
      if (micro)
        return `${int}${unit[0]}`;
      return relativeFormat.format(int, unit);
    }
    if (tense === "future" || tense === "auto" && inFuture && within) {
      const [int, unit] = micro ? microTimeUntil(date) : timeUntil(date);
      if (micro)
        return `${int}${unit[0]}`;
      return relativeFormat.format(int, unit);
    }
    const formatter = new DateTimeFormat2(locale, {
      second: this.second,
      minute: this.minute,
      hour: this.hour,
      weekday: this.weekday,
      day: this.day,
      month: this.month,
      year: this.year,
      timeZoneName: this.timeZoneName
    });
    return `${this.prefix} ${formatter.format(date)}`.trim();
  }
  get second() {
    const second = this.getAttribute("second");
    if (second === "numeric" || second === "2-digit")
      return second;
  }
  set second(value) {
    this.setAttribute("second", value || "");
  }
  get minute() {
    const minute = this.getAttribute("minute");
    if (minute === "numeric" || minute === "2-digit")
      return minute;
  }
  set minute(value) {
    this.setAttribute("minute", value || "");
  }
  get hour() {
    const hour = this.getAttribute("hour");
    if (hour === "numeric" || hour === "2-digit")
      return hour;
  }
  set hour(value) {
    this.setAttribute("hour", value || "");
  }
  get weekday() {
    const weekday = this.getAttribute("weekday");
    if (weekday === "long" || weekday === "short" || weekday === "narrow")
      return weekday;
  }
  set weekday(value) {
    this.setAttribute("weekday", value || "");
  }
  get day() {
    var _a;
    const day = (_a = this.getAttribute("day")) !== null && _a !== void 0 ? _a : "numeric";
    if (day === "numeric" || day === "2-digit")
      return day;
  }
  set day(value) {
    this.setAttribute("day", value || "");
  }
  get month() {
    var _a;
    const month = (_a = this.getAttribute("month")) !== null && _a !== void 0 ? _a : "short";
    if (month === "numeric" || month === "2-digit" || month === "short" || month === "long" || month === "narrow") {
      return month;
    }
  }
  set month(value) {
    this.setAttribute("month", value || "");
  }
  get year() {
    var _a;
    const year = this.getAttribute("year");
    if (year === "numeric" || year === "2-digit")
      return year;
    if (!this.hasAttribute("year") && new Date().getUTCFullYear() !== ((_a = this.date) === null || _a === void 0 ? void 0 : _a.getUTCFullYear())) {
      return "numeric";
    }
  }
  set year(value) {
    this.setAttribute("day", value || "");
  }
  get timeZoneName() {
    const name = this.getAttribute("time-zone-name");
    if (name === "long" || name === "short" || name === "shortOffset" || name === "longOffset" || name === "shortGeneric" || name === "longGeneric") {
      return name;
    }
  }
  set timeZoneName(value) {
    this.setAttribute("time-zone-name", value || "");
  }
  get prefix() {
    var _a;
    return (_a = this.getAttribute("prefix")) !== null && _a !== void 0 ? _a : "on";
  }
  set prefix(value) {
    this.setAttribute("prefix", value);
  }
  get threshold() {
    const threshold = this.getAttribute("threshold");
    return threshold && isDuration(threshold) ? threshold : "P30D";
  }
  set threshold(value) {
    this.setAttribute("threshold", value);
  }
  get tense() {
    const tense = this.getAttribute("tense");
    if (tense === "past")
      return "past";
    if (tense === "future")
      return "future";
    return "auto";
  }
  set tense(value) {
    this.setAttribute("tense", value);
  }
  get precision() {
    const precision = this.getAttribute("precision");
    if (unitNames.includes(precision))
      return precision;
    return "second";
  }
  set precision(value) {
    this.setAttribute("precision", value);
  }
  get format() {
    const format = this.getAttribute("format");
    if (format === "micro")
      return "micro";
    if (format === "elapsed")
      return "elapsed";
    if (format && format.includes("%"))
      return format;
    return "auto";
  }
  set format(value) {
    this.setAttribute("format", value);
  }
  get datetime() {
    return this.getAttribute("datetime") || "";
  }
  set datetime(value) {
    this.setAttribute("datetime", value);
  }
  get date() {
    const parsed = Date.parse(this.datetime);
    return Number.isNaN(parsed) ? null : new Date(parsed);
  }
  set date(value) {
    this.datetime = (value === null || value === void 0 ? void 0 : value.toISOString()) || "";
  }
  connectedCallback() {
    this.update();
  }
  disconnectedCallback() {
    dateObserver.unobserve(this);
  }
  attributeChangedCallback(attrName, oldValue, newValue) {
    if (oldValue === newValue)
      return;
    if (attrName === "title") {
      __classPrivateFieldSet2(this, _RelativeTimeElement_customTitle, newValue !== null && this.getFormattedTitle() !== newValue, "f");
    }
    if (!__classPrivateFieldGet2(this, _RelativeTimeElement_updating, "f") && !(attrName === "title" && __classPrivateFieldGet2(this, _RelativeTimeElement_customTitle, "f"))) {
      __classPrivateFieldSet2(this, _RelativeTimeElement_updating, (async () => {
        await Promise.resolve();
        this.update();
      })(), "f");
    }
  }
  update() {
    const oldText = __classPrivateFieldGet2(this, _RelativeTimeElement_renderRoot, "f").textContent || "";
    const oldTitle = this.getAttribute("title") || "";
    let newTitle = oldTitle;
    let newText = oldText;
    const now = new Date();
    if (!__classPrivateFieldGet2(this, _RelativeTimeElement_customTitle, "f")) {
      newTitle = this.getFormattedTitle() || "";
      if (newTitle)
        this.setAttribute("title", newTitle);
    }
    newText = this.getFormattedDate(now) || "";
    if (newText) {
      __classPrivateFieldGet2(this, _RelativeTimeElement_renderRoot, "f").textContent = newText;
    } else if (this.shadowRoot === __classPrivateFieldGet2(this, _RelativeTimeElement_renderRoot, "f") && this.textContent) {
      __classPrivateFieldGet2(this, _RelativeTimeElement_renderRoot, "f").textContent = this.textContent;
    }
    if (newText !== oldText || newTitle !== oldTitle) {
      this.dispatchEvent(new RelativeTimeUpdatedEvent(oldText, newText, oldTitle, newTitle));
    }
    const date = this.date;
    const format = this.format;
    const isRelative = (format === "auto" || format === "micro") && date && withinDuration(now, date, this.threshold);
    if (format === "elapsed" || isRelative) {
      dateObserver.observe(this);
    } else {
      dateObserver.unobserve(this);
    }
    __classPrivateFieldSet2(this, _RelativeTimeElement_updating, false, "f");
  }
};
__name(RelativeTimeElement, "RelativeTimeElement");
_RelativeTimeElement_customTitle = /* @__PURE__ */ new WeakMap(), _RelativeTimeElement_updating = /* @__PURE__ */ new WeakMap(), _RelativeTimeElement_renderRoot = /* @__PURE__ */ new WeakMap(), _RelativeTimeElement_instances = /* @__PURE__ */ new WeakSet(), _RelativeTimeElement_lang_get = /* @__PURE__ */ __name(function _RelativeTimeElement_lang_get2() {
  var _a, _b;
  return (_b = (_a = this.closest("[lang]")) === null || _a === void 0 ? void 0 : _a.getAttribute("lang")) !== null && _b !== void 0 ? _b : "default";
}, "_RelativeTimeElement_lang_get");

// dist/local-time-element.js
var LocalTimeElement = class extends RelativeTimeElement {
  get prefix() {
    return "";
  }
  get format() {
    if (super.format.includes("%"))
      return super.format;
    if (!this.day && !this.month && !this.year && !this.timeZoneName && !this.hour && !this.minute)
      return "";
    return "auto";
  }
  get day() {
    const day = this.getAttribute("day");
    if (day === "numeric" || day === "2-digit")
      return day;
  }
  get month() {
    const month = this.getAttribute("month");
    if (month === "numeric" || month === "2-digit" || month === "short" || month === "long" || month === "narrow") {
      return month;
    }
  }
  get year() {
    const year = this.getAttribute("year");
    if (year === "numeric" || year === "2-digit")
      return year;
  }
};
__name(LocalTimeElement, "LocalTimeElement");

// dist/local-time-element-define.js
var root2 = typeof globalThis !== "undefined" ? globalThis : window;
try {
  customElements.define("local-time", LocalTimeElement);
  root2.LocalTimeElement = LocalTimeElement;
} catch (e) {
  if (!(root2.DOMException && e instanceof DOMException && e.name === "NotSupportedError") && !(e instanceof ReferenceError)) {
    throw e;
  }
}
var local_time_element_define_default = LocalTimeElement;

// dist/relative-time-element-define.js
var root3 = typeof globalThis !== "undefined" ? globalThis : window;
try {
  customElements.define("relative-time", RelativeTimeElement);
  root3.RelativeTimeElement = RelativeTimeElement;
} catch (e) {
  if (!(root3.DOMException && e instanceof DOMException && e.name === "NotSupportedError") && !(e instanceof ReferenceError)) {
    throw e;
  }
}
var relative_time_element_define_default = RelativeTimeElement;

// dist/time-ago-element.js
var TimeAgoElement = class extends RelativeTimeElement {
  get tense() {
    return "past";
  }
};
__name(TimeAgoElement, "TimeAgoElement");

// dist/time-ago-element-define.js
var root4 = typeof globalThis !== "undefined" ? globalThis : window;
try {
  customElements.define("time-ago", TimeAgoElement);
  root4.TimeAgoElement = TimeAgoElement;
} catch (e) {
  if (!(root4.DOMException && e instanceof DOMException && e.name === "NotSupportedError") && !(e instanceof ReferenceError)) {
    throw e;
  }
}
var time_ago_element_define_default = TimeAgoElement;

// dist/time-until-element.js
var TimeUntilElement = class extends RelativeTimeElement {
  get tense() {
    return "future";
  }
};
__name(TimeUntilElement, "TimeUntilElement");

// dist/time-until-element-define.js
var root5 = typeof globalThis !== "undefined" ? globalThis : window;
try {
  customElements.define("time-until", TimeUntilElement);
  root5.TimeUntilElement = TimeUntilElement;
} catch (e) {
  if (!(root5.DOMException && e instanceof DOMException && e.name === "NotSupportedError") && !(e instanceof ReferenceError)) {
    throw e;
  }
}
var time_until_element_define_default = TimeUntilElement;
export {
  local_time_element_define_default as LocalTimeElement,
  relative_time_element_define_default as RelativeTimeElement,
  time_ago_element_define_default as TimeAgoElement,
  time_until_element_define_default as TimeUntilElement
};
